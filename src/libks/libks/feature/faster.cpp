#include "libks/feature/faster.h"
#include "libks/feature/extendedfast.h"

using namespace cv;
using namespace std;
using namespace ks;

void fastNonmaxSuppression(const vector<Point>& corners,
	const vector<int>& scores, vector<KeyPoint>& ret_nonmax);

void FASTER(const Mat_<unsigned char>& image, vector<KeyPoint>& keypoints, int threshold,
	bool nonmax_suppression) {

	// This code was adapted from cv::FAST
	vector<Point> corners;
    faster_detect(image, corners, threshold);
 
    if(nonmax_suppression)
    {
        vector<int> scores;
        faster_score(image, corners, threshold, scores);
        fastNonmaxSuppression(corners, scores, keypoints);
    }
    else
    {   
        size_t i, n = corners.size();
        keypoints.resize(n);
        for( i = 0; i < n; i++ )
            keypoints[i] = KeyPoint(corners[i], 6.f);
    }
}

// This function is part of the autogenerated code
void make_offsets(int pixel[], int row_stride)
{
        pixel[0] = -1 + row_stride * -4;
        pixel[1] = 0 + row_stride * -4;
        pixel[2] = 1 + row_stride * -4;
        pixel[3] = -2 + row_stride * -3;
        pixel[4] = -1 + row_stride * -3;
        pixel[5] = 0 + row_stride * -3;
        pixel[6] = 1 + row_stride * -3;
        pixel[7] = 2 + row_stride * -3;
        pixel[8] = -3 + row_stride * -2;
        pixel[9] = -2 + row_stride * -2;
        pixel[10] = -1 + row_stride * -2;
        pixel[11] = 0 + row_stride * -2;
        pixel[12] = 1 + row_stride * -2;
        pixel[13] = 2 + row_stride * -2;
        pixel[14] = 3 + row_stride * -2;
        pixel[15] = -4 + row_stride * -1;
        pixel[16] = -3 + row_stride * -1;
        pixel[17] = -2 + row_stride * -1;
        pixel[18] = 2 + row_stride * -1;
        pixel[19] = 3 + row_stride * -1;
        pixel[20] = 4 + row_stride * -1;
        pixel[21] = -4 + row_stride * 0;
        pixel[22] = -3 + row_stride * 0;
        pixel[23] = -2 + row_stride * 0;
        pixel[24] = 2 + row_stride * 0;
        pixel[25] = 3 + row_stride * 0;
        pixel[26] = 4 + row_stride * 0;
        pixel[27] = -4 + row_stride * 1;
        pixel[28] = -3 + row_stride * 1;
        pixel[29] = -2 + row_stride * 1;
        pixel[30] = 2 + row_stride * 1;
        pixel[31] = 3 + row_stride * 1;
        pixel[32] = 4 + row_stride * 1;
        pixel[33] = -3 + row_stride * 2;
        pixel[34] = -2 + row_stride * 2;
        pixel[35] = -1 + row_stride * 2;
        pixel[36] = 0 + row_stride * 2;
        pixel[37] = 1 + row_stride * 2;
        pixel[38] = 2 + row_stride * 2;
        pixel[39] = 3 + row_stride * 2;
        pixel[40] = -2 + row_stride * 3;
        pixel[41] = -1 + row_stride * 3;
        pixel[42] = 0 + row_stride * 3;
        pixel[43] = 1 + row_stride * 3;
        pixel[44] = 2 + row_stride * 3;
        pixel[45] = -1 + row_stride * 4;
        pixel[46] = 0 + row_stride * 4;
        pixel[47] = 1 + row_stride * 4;
}

// The following code has been copied from OpenCV
// Original author: Edward Rosten

/* This defines non-strict maxima */
#define Compare(X, Y) ((X)>=(Y))

/* This is a fast, integer only, sparse nonmaximal suppression. */
/* probably only useful for FAST corner detection */
void fastNonmaxSuppression(const vector<Point>& corners,
	const vector<int>& scores, vector<KeyPoint>& ret_nonmax)
{
	int i, j, num_corners = (int)corners.size(); 

	// Point above points (roughly) to the pixel above the one of interest, if there is a feature there.
	int point_above = 0;
	int point_below = 0;

	ret_nonmax.clear();
	if(num_corners < 1)
		return;

	/* Find where each row begins
	   (the corners are output in raster scan order). A beginning of -1 signifies
	   that there are no corners on that row. */
	int last_row = corners[num_corners-1].y;
	vector<int> row_start(last_row+1);

	for(i=0; i < last_row+1; i++)
		row_start[i] = -1;

	int prev_row = -1;
	for(i=0; i< num_corners; i++)
		if(corners[i].y != prev_row)
		{
			row_start[corners[i].y] = i;
			prev_row = corners[i].y;
		}

	ret_nonmax.reserve(num_corners);
	for(i = 0; i < num_corners; i++)
	{
		int score = scores[i];
		Point pos = corners[i];
	
		// Check left
		if(i > 0 && corners[i-1].x == pos.x-1 && corners[i-1].y == pos.y && Compare(scores[i-1], score))
			continue;
	
		// Check right
		if(i < num_corners-1 && corners[i+1].x == pos.x+1 && corners[i+1].y == pos.y && Compare(scores[i+1], score))
			continue;

		bool suppressed = false;
		// Check above (if there is a valid row above)
		if(pos.y != 0 && row_start[pos.y - 1] != -1) 
		{
			// Make sure that current point_above is one row above.
			if(corners[point_above].y < pos.y - 1)
				point_above = row_start[pos.y-1];
	
			// Make point_above point to the first of the pixels above the current point, if it exists.
			for(; corners[point_above].y < pos.y && corners[point_above].x < pos.x - 1; point_above++)
				;
	
			for(j=point_above; corners[j].y < pos.y && corners[j].x <= pos.x + 1; j++)
			{
				int x = corners[j].x;
				if( (x == pos.x - 1 || x ==pos.x || x == pos.x+1) && Compare(scores[j], score))
				{
					suppressed = true;
					break;
				}
			}
			if( suppressed )
				continue;
		}
	
		// Check below (if there is anything below)
		if(pos.y != last_row && row_start[pos.y + 1] != -1 && point_below < num_corners) // Nothing below
		{
			if(corners[point_below].y < pos.y + 1)
				point_below = row_start[pos.y+1];
	
			// Make point below point to one of the pixels belowthe current point, if it exists.
			for(; point_below < num_corners && corners[point_below].y == pos.y+1
				&& corners[point_below].x < pos.x - 1; point_below++)
				;

			for(j=point_below; j < num_corners && corners[j].y == pos.y+1 && corners[j].x <= pos.x + 1; j++)
			{
				int x = corners[j].x;
				if( (x == pos.x - 1 || x ==pos.x || x == pos.x+1) && Compare(scores[j],score))
				{
					suppressed = true;
					break;
				}
			}
			if( suppressed )
				continue;
		}

		ret_nonmax.push_back(KeyPoint(corners[i], 6.f, -1.f, (float)score));
	}
}
